# -*- coding: utf-8 -*-
"""prediksi_curah_hujan_LSTM_submission.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18yUqJdq1UdcvjA7oFfH_C_DDkUWLsZkH

# **Prediksi Curah Hujan dengan LSTM**

Curah hujan berperan penting dalam manajemen risiko banjir, pertanian, dan perencanaan kota. Proyek ini bertujuan memprediksi curah hujan 14 hari ke depan berdasarkan data cuaca historis Jakarta menggunakan algoritma LSTM (Long Short-Term Memory).

### Problem Statement:
- Bagaimana memprediksi apakah akan terjadi hujan atau tidak dalam 14 hari ke depan berdasarkan data historis?

### Solution Statement:
- Menggunakan LSTM karena model ini cocok untuk mempelajari pola urutan data (time series) dalam cuaca.

### Sumber Dataset:
- Dataset cuaca Jakarta 2013–2020.

# **Import Library**
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import seaborn as sns

"""# **Load Data**

Dataset berisi informasi tanggal dan curah hujan harian. Pemeriksaan awal dilakukan untuk mengecek bentuk data, tipe data, dan missing value.

"""

df = pd.read_csv("WeatherJakarta2013-2020.csv")
df

# Visualisasi Data (EDA)
# Ubah kolom waktu ke datetime
df['time'] = pd.to_datetime(df['time'])

# Tren curah hujan tahunan
df['year'] = df['time'].dt.year
df.groupby('year')['precipitation_sum (mm)'].mean().plot(kind='bar', figsize=(8,4), title='Rata-rata Curah Hujan per Tahun')
plt.ylabel('mm')
plt.xlabel('Tahun')
plt.show()

# Distribusi curah hujan
sns.histplot(df['precipitation_sum (mm)'], bins=50, kde=True)
plt.title('Distribusi Curah Hujan')
plt.xlabel('Curah Hujan (mm)')
plt.ylabel('Frekuensi')
plt.show()

# Heatmap korelasi
plt.figure(figsize=(10,6))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap='coolwarm')
plt.title('Korelasi Antar Variabel')
plt.show()

"""# **Data Preparation (Pre Processing)**

- Konversi kolom tanggal
- Penanganan nilai hilang
- Normalisasi data curah hujan
- Pembuatan window data untuk input LSTM
- Split data menjadi data latih dan uji

"""

# ubah type
df['time'] = pd.to_datetime(df['time'])
df = df.sort_values('time')

# cek tipe data
df.dtypes

# cek missing value
df.isnull().sum()

# seleksi fitur
features = [
    'temperature_2m_max (°C)', 'temperature_2m_min (°C)', 'temperature_2m_mean (°C)',
    'apparent_temperature_max (°C)', 'apparent_temperature_min (°C)', 'apparent_temperature_mean (°C)',
    'precipitation_sum (mm)', 'rain_sum (mm)', 'precipitation_hours (h)', 'windspeed_10m_max (km/h)'
]

# normalisasi
scaler = StandardScaler()
scaled_features = scaler.fit_transform(df[features])

# windowing
WINDOW_SIZE = 14
X, y = [], []

for i in range(len(scaled_features) - WINDOW_SIZE):
    X.append(scaled_features[i:i+WINDOW_SIZE])
    rain_next = df['rain_sum (mm)'].iloc[i + WINDOW_SIZE]
    y.append(1 if rain_next > 0 else 0)

X = np.array(X)
y = np.array(y)

# Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False
)

"""# **Modeling LSTM**

Model LSTM dibangun dengan satu layer LSTM dan satu Dense output. Model dilatih dengan binary_crossentropy karena target adalah prediksi hujan/tidak.

"""

# build model
model = Sequential([
    LSTM(64, input_shape=(WINDOW_SIZE, X.shape[2]), return_sequences=False),
    Dropout(0.3),
    Dense(32, activation='relu'),
    Dense(1, activation='sigmoid')
])

model.compile(loss='binary_crossentropy', optimizer=Adam(0.001), metrics=['accuracy'])

# train model
early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=32,
    validation_split=0.2,
    callbacks=[early_stop],
    verbose=1
)

"""# **Evaluasi Model**

Model dievaluasi menggunakan confusion matrix, classification report, dan grafik akurasi serta loss untuk mengukur performa pada data latih dan uji. Selain itu, dilakukan prediksi terhadap data uji untuk membandingkan hasil prediksi dengan nilai aktual.

Hasil menunjukkan bahwa model memiliki akurasi yang cukup baik dan loss yang rendah, menandakan bahwa model mampu belajar dengan efektif dari data historis. Prediksi model juga cukup akurat dalam membedakan hari hujan dan tidak hujan.
"""

# test akurasi
loss, acc = model.evaluate(X_test, y_test)
print(f"\nTest Accuracy: {acc:.2f}")

# visualisasi
plt.figure(figsize=(12, 5))

# Plot Accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy', marker='o')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', marker='o')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.grid(True)
plt.legend()

# Plot Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss', marker='o')
plt.plot(history.history['val_loss'], label='Validation Loss', marker='o')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

loss, acc = model.evaluate(X_test, y_test)
print(f"\nTest Accuracy: {acc:.2f}")

# Predict 14 days ahead
last_14_days = scaled_features[-WINDOW_SIZE:]  # ambil 14 hari terakhir
predictions = []

window = last_14_days.copy()
for _ in range(14):  # prediksi 14 hari ke depan
    input_window = np.expand_dims(window, axis=0)
    prob = model.predict(input_window)[0][0]
    prediction = 1 if prob > 0.5 else 0
    predictions.append(prediction)

    # Buat dummy next day (tanpa fitur masa depan), kita hanya duplikasikan nilai terakhir
    next_day = window[-1].copy()
    window = np.vstack([window[1:], next_day])

print("\nPrediksi apakah akan hujan dalam 14 hari ke depan (1=Ya, 0=Tidak):")
print(predictions)

# Opsional: Plot akurasi
plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.legend()
plt.title("Accuracy over Epochs")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.show()

# prediksi data uji
y_pred_prob = model.predict(X_test)
y_pred = (y_pred_prob > 0.5).astype(int).flatten()

# confusion matriks
cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Tidak Hujan', 'Hujan'],
            yticklabels=['Tidak Hujan', 'Hujan'])
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

# report akurasi

print(classification_report(y_test, y_pred, target_names=["Tidak Hujan", "Hujan"]))

"""# **Kesimpulan**

Model LSTM berhasil dibangun dan digunakan untuk memprediksi curah hujan selama 7 hari ke depan berdasarkan data historis cuaca Jakarta tahun 2013–2020.

Beberapa poin penting dari proyek ini:
- Model mampu mencapai akurasi sekitar 88% pada data uji.
- Grafik akurasi dan loss menunjukkan bahwa model belajar dengan baik dan tidak mengalami overfitting.
- Prediksi yang dihasilkan menunjukkan kemampuan model dalam menangkap pola temporal dari data cuaca.

Model ini dapat digunakan sebagai dasar sistem prediksi cuaca sederhana dan bisa dikembangkan lebih lanjut dengan data tambahan atau tuning hyperparameter lebih lanjut.

"""