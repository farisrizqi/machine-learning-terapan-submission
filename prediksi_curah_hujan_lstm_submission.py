# -*- coding: utf-8 -*-
"""prediksi_curah_hujan_LSTM_submission.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18yUqJdq1UdcvjA7oFfH_C_DDkUWLsZkH

# **Prediksi Curah Hujan dengan LSTM**

Curah hujan berperan penting dalam manajemen risiko banjir, pertanian, dan perencanaan kota. Proyek ini bertujuan memprediksi curah hujan 14 hari ke depan berdasarkan data cuaca historis Jakarta menggunakan algoritma LSTM (Long Short-Term Memory).

### Problem Statement:
- Bagaimana memprediksi apakah akan terjadi hujan atau tidak dalam 14 hari ke depan berdasarkan data historis?

### Solution Statement:
- Menggunakan LSTM karena model ini cocok untuk mempelajari pola urutan data (time series) dalam cuaca.

### Sumber Dataset:
- Dataset cuaca Jakarta 2013–2020.

# **Import Library**
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import seaborn as sns

"""# **Load Data**

Dataset berisi informasi tanggal dan curah hujan harian. Pemeriksaan awal dilakukan untuk mengecek bentuk data, tipe data, dan missing value.

"""

df = pd.read_csv("WeatherJakarta2013-2020.csv")
df

"""# **Visualisasi Data (EDA)**"""

# Ubah kolom waktu ke datetime
df['time'] = pd.to_datetime(df['time'])

# Tren curah hujan tahunan
df['year'] = df['time'].dt.year
df.groupby('year')['precipitation_sum (mm)'].mean().plot(kind='bar', figsize=(8,4), title='Rata-rata Curah Hujan per Tahun')
plt.ylabel('mm')
plt.xlabel('Tahun')
plt.show()

# Distribusi curah hujan
sns.histplot(df['precipitation_sum (mm)'], bins=50, kde=True)
plt.title('Distribusi Curah Hujan')
plt.xlabel('Curah Hujan (mm)')
plt.ylabel('Frekuensi')
plt.show()

# Heatmap korelasi
plt.figure(figsize=(10,6))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap='coolwarm')
plt.title('Korelasi Antar Variabel')
plt.show()

"""insight : Menghasilkan Visualisasi agar mudah dimengerti oleh audiens melalui diagram Explarotory data

# **Data Preparation (Pre Processing)**

- Konversi kolom tanggal
- Penanganan nilai hilang
- Normalisasi data curah hujan
- Pembuatan window data untuk input LSTM
- Split data menjadi data latih dan uji
"""

# ubah type
df['time'] = pd.to_datetime(df['time'])
df = df.sort_values('time')

# cek tipe data
df.dtypes

# cek missing value
df.isnull().sum()

# seleksi fitur
features = [
    'temperature_2m_max (°C)', 'temperature_2m_min (°C)', 'temperature_2m_mean (°C)',
    'apparent_temperature_max (°C)', 'apparent_temperature_min (°C)', 'apparent_temperature_mean (°C)',
    'precipitation_sum (mm)', 'rain_sum (mm)', 'precipitation_hours (h)', 'windspeed_10m_max (km/h)'
]

# normalisasi
scaler = StandardScaler()
scaled_features = scaler.fit_transform(df[features])

"""insight:
1. **Seleksi Fitur**  
   Dipilih 10 fitur cuaca yang dianggap relevan terhadap kejadian hujan, seperti suhu maksimum/minimum, suhu terasa, curah hujan, durasi hujan, dan kecepatan angin maksimum.

2. **Normalisasi Data**  
   Semua fitur dinormalisasi menggunakan `StandardScaler` agar memiliki skala yang seragam. Hal ini penting untuk mencegah bias pada model terhadap fitur dengan nilai lebih besar dan mempercepat proses pelatihan.
"""

# windowing
WINDOW_SIZE = 14
X, y = [], []

for i in range(len(scaled_features) - WINDOW_SIZE):
    X.append(scaled_features[i:i+WINDOW_SIZE])
    rain_next = df['rain_sum (mm)'].iloc[i + WINDOW_SIZE]
    y.append(1 if rain_next > 0 else 0)

X = np.array(X)
y = np.array(y)

"""insight:
- **Pembuatan Data Sekuensial (Windowing)**  
   Data diubah menjadi bentuk sekuensial dengan `WINDOW_SIZE = 14`, artinya model akan mempelajari pola cuaca selama 14 hari terakhir untuk memprediksi apakah akan hujan di hari ke-15.
"""

# Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False
)

"""insight:
- **Split Data Tanpa Pengacakan**  
   Data dibagi menjadi data latih dan data uji tanpa pengacakan (`shuffle=False`) untuk menjaga urutan waktu. Ini penting dalam prediksi berbasis time series agar model diuji pada data masa depan yang belum pernah dilihat.

# **Modeling LSTM**

Model LSTM dibangun dengan satu layer LSTM dan satu Dense output. Model dilatih dengan binary_crossentropy karena target adalah prediksi hujan/tidak.
"""

# build model
model = Sequential([
    LSTM(64, input_shape=(WINDOW_SIZE, X.shape[2]), return_sequences=False),
    Dropout(0.3),
    Dense(32, activation='relu'),
    Dense(1, activation='sigmoid')
])

model.compile(loss='binary_crossentropy', optimizer=Adam(0.001), metrics=['accuracy'])

# train model
early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=32,
    validation_split=0.2,
    callbacks=[early_stop],
    verbose=1
)

"""insight:

Model LSTM dibangun untuk mempelajari pola data sekuensial cuaca selama 14 hari. Arsitektur terdiri dari:
- 1 lapisan LSTM dengan 64 unit,
- Dropout 0.3 untuk mencegah overfitting,
- Dense layer 32 unit (ReLU),
- Output layer sigmoid untuk klasifikasi biner (hujan/tidak).

Model dilatih dengan:
- Loss: `binary_crossentropy` (sesuai klasifikasi),
- Optimizer: Adam (learning rate 0.001),
- Epochs: 30, Batch size: 32,
- Validasi 20% dari data latih,
- EarlyStopping untuk menghentikan pelatihan dini jika val_loss tidak membaik selama 5 epoch.

Tujuannya adalah membangun model yang mampu memprediksi hujan secara akurat berdasarkan pola cuaca harian sebelumnya.

# **Evaluasi Model**

Model dievaluasi menggunakan confusion matrix, classification report, dan grafik akurasi serta loss untuk mengukur performa pada data latih dan uji. Selain itu, dilakukan prediksi terhadap data uji untuk membandingkan hasil prediksi dengan nilai aktual.

Hasil menunjukkan bahwa model memiliki akurasi yang cukup baik dan loss yang rendah, menandakan bahwa model mampu belajar dengan efektif dari data historis. Prediksi model juga cukup akurat dalam membedakan hari hujan dan tidak hujan.
"""

# test akurasi
loss, acc = model.evaluate(X_test, y_test)
print(f"\nTest Accuracy: {acc:.2f}")

# visualisasi
plt.figure(figsize=(12, 5))

# Plot Accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy', marker='o')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', marker='o')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.grid(True)
plt.legend()

# Plot Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss', marker='o')
plt.plot(history.history['val_loss'], label='Validation Loss', marker='o')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

loss, acc = model.evaluate(X_test, y_test)
print(f"\nTest Accuracy: {acc:.2f}")

# Predict 14 days ahead
last_14_days = scaled_features[-WINDOW_SIZE:]  # ambil 14 hari terakhir
predictions = []

window = last_14_days.copy()
for _ in range(14):  # prediksi 14 hari ke depan
    input_window = np.expand_dims(window, axis=0)
    prob = model.predict(input_window)[0][0]
    prediction = 1 if prob > 0.5 else 0
    predictions.append(prediction)

    # Buat dummy next day (tanpa fitur masa depan), kita hanya duplikasikan nilai terakhir
    next_day = window[-1].copy()
    window = np.vstack([window[1:], next_day])

print("\nPrediksi apakah akan hujan dalam 14 hari ke depan (1=Ya, 0=Tidak):")
print(predictions)

# Opsional: Plot akurasi
plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.legend()
plt.title("Accuracy over Epochs")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.show()

# prediksi data uji
y_pred_prob = model.predict(X_test)
y_pred = (y_pred_prob > 0.5).astype(int).flatten()

# confusion matriks
cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Tidak Hujan', 'Hujan'],
            yticklabels=['Tidak Hujan', 'Hujan'])
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

# report akurasi

print(classification_report(y_test, y_pred, target_names=["Tidak Hujan", "Hujan"]))

"""# **Kesimpulan**

Model LSTM berhasil dibangun dan digunakan untuk memprediksi kemungkinan terjadinya hujan pada hari ke-15 berdasarkan pola cuaca 14 hari sebelumnya, menggunakan data historis cuaca Jakarta tahun 2013–2020.

Beberapa poin penting dari proyek ini:

- Model mampu mencapai **akurasi sekitar 82%** pada data uji, menunjukkan performa yang cukup baik dalam klasifikasi biner (hujan / tidak hujan).
- Evaluasi metrik menunjukkan model sangat baik dalam mengenali kelas **"Hujan"** (F1-Score: 0.88), meskipun performa pada kelas **"Tidak Hujan"** masih bisa ditingkatkan.
- Grafik akurasi dan loss selama pelatihan menunjukkan proses pembelajaran berjalan stabil tanpa indikasi overfitting.
- Model mampu menangkap pola temporal dari data cuaca harian dan dapat dijadikan dasar pengembangan sistem prediksi cuaca sederhana.
- Ke depannya, model ini dapat ditingkatkan dengan:
  - Penambahan fitur cuaca lain (misalnya kelembapan, tekanan udara),
  - Penyesuaian arsitektur dan hyperparameter (seperti jumlah unit, dropout, atau window size),
  - Penggunaan model sekuensial lain seperti GRU atau Transformer untuk perbandingan performa.


Model ini dapat digunakan sebagai dasar sistem prediksi cuaca sederhana dan bisa dikembangkan lebih lanjut dengan data tambahan atau tuning hyperparameter lebih lanjut.

"""
